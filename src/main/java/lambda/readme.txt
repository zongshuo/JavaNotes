使用前提：使用lambda必须具有函数接口，即接口中有且只有一个抽象方法。

函数接口：接口中有且仅有一个抽象方法
          Runnable a = new Runnable(){};
@FunctionalInterface：函数接口的协议注解。

::：方法引用符，通过类名直接引用方法。类名称::方法名。


组成部分：参数、箭头、代码
    1、小括号内的语法与传统方法参数一致，无则留空，多个参数则用逗号分隔。
        小括号内参数的类型可以省略。
        如果小括号内有且只有一个参数，小括号可以省略。
    2、箭头（->）代表指向动作
    3、大括号内与传统方法体一致，
        如果大括号内有且仅有一行语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。

lambda有四个默认的函数式接口：
    1、Consumer<T>(消费型接口)：对类型为T的对象进行操作，但没有任何返回。
    2、Supplier<T>（供给型接口）：不要参数，只返回T类型的对象。
    3、Function<T, R>（函数型接口）：接受T类型对象，返回R类型参数。
    4、Predicate<T>（断言型接口）：接收T类型对象，返回boolean类型结果。

应用场景：
    1、使用()->{}替代匿名类，只能替代函数式接口的匿名类。实际上lambda的类型对应的就是对应函数接口的类型。
        lambda表达式的另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显示指定。
    2、以流水线的方式处理数据
    3、更简单的并行数据处理

lambda并行数据处理：Lambda并行数据处理只需要在stream方法后面加上parallel方法即可，其底层框架是fork/join,默认并行行数nCPU数量。
lambda表达式中的stream不是集合元素，像是更高级的iterator，能够在遍历的过程中指定各种操作。
lambda应该简单易读，不应操作外部变量(函数式编程)。

Stream不是数据结构，不会保存数据，不会修改原有数据，会将操作后的数据保存到另外的对象。
    流在中间处理过程中，支队操作进行记录，并不会立即执行，在执行终止操作的时候才会进行实际的计算。
Stream：
    1、中间操作
        A、无状态：处理不受前一个元素的影响
        B、有状态：获取所有元素后才能处理
    2、结束操作
        A、非短路操作：处理全部后才有结果
        B、短路操作：符合某条件即可获取结果